闭包是在一个函数里声明了另外一个函数，并且这个函数访问了父函数作用域里的变量   
其实每个函数都带一个闭包，只是在一个函数里面声明并返回另一个函数，且这个函数访问了副函数的变量，才需要注意闭包
```
function createCounter() {
  let counter = 0;
  const myFunction = function() {
    counter = counter + 1;
    return counter;
  }
  return myFunction;
}

const increment = createCounter();
const c1 = increment();
const c2 = increment();
const c3 = increment();
console.log('example increment', c1, c2, c3)
```
1. 第1-8行。我们在全局执行上下文中创建了一个新的变量createCounter，它得到了指定的函数定义。
2. 第9行。我们在全局执行上下文中声明了一个名为increment的新变量。
3. 第9行。我们需要调用createCounter函数并将其返回值赋给increment变量。
4. 第1-8行。调用函数，创建新的本地执行上下文。
5. 第2行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0 。
6. 第3-6行。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第4行和第5行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量counter(值为0)。
7. 第7行。返回myFunction变量的内容,删除本地执行上下文。myFunction和counter不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。
8. 第9行。在调用上下文(全局执行上下文)中，createCounter返回的值被指定为increment，变量increment现在包含一个函数定义(和闭包),由createCounter返回的函数定义,它不再标记为myFunction，但它的定义是相同的,在全局上下文中，称为increment。（注意myFunction进入全局作用域之后是个匿名函数了哦）
9. 第10行。声明一个新变量c1。
10. 继续第10行。查找变量increment，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。
11. 创建一个新的执行上下文，没有参数，开始执行函数。
12. 第4行。counter = counter + 1，寻找变量 counter，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为counter的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 counter。

Question:  闭包和上下文，查找顺序是什么？