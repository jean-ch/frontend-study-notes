#### 闭包
##### 一个完整的闭包详解
```
1.  function createCounter() {
2.    let counter = 0;
3.    const myFunction = function() {
4.      counter = counter + 1;
5.      return counter;
6.    }
7.    return myFunction;
8.  }
9.  const increment = createCounter();
10. const c1 = increment();
11. const c2 = increment();
12. const c3 = increment();
13. console.log('example increment', c1, c2, c3)
```
1. 第1-8行。我们在全局执行上下文中创建了一个新的变量createCounter，它得到了指定的函数定义。
2. 第9行。我们在全局执行上下文中声明了一个名为increment的新变量。
3. 第9行。我们需要调用createCounter函数并将其返回值赋给increment变量。
4. 第1-8行。调用函数，创建新的本地执行上下文。
5. 第2行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0 。
6. 第3-6行。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第4行和第5行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量counter(值为0)。
7. 第7行。返回myFunction变量的内容,删除本地执行上下文。myFunction和counter不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。
8. 第9行。在调用上下文(全局执行上下文)中，createCounter返回的值被指定为increment，变量increment现在包含一个函数定义(和闭包),由createCounter返回的函数定义,它不再标记为myFunction，但它的定义是相同的,在全局上下文中，称为increment。（注意myFunction进入全局作用域之后是个匿名函数了哦）
9. 第10行。声明一个新变量c1。
10. 继续第10行。查找变量increment，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。
11. 创建一个新的执行上下文，没有参数，开始执行函数。
12. 第4行。counter = counter + 1，寻找变量 counter，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为counter的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 counter。


##### 闭包是什么
- 函数作用域和作用域继承 
  - 作用域栈： 子函数的作用域栈包括上级函数的作用域和当前函数的作用域
  - 变量的作用域属于函数作用域
- 内存回收机制
  - 函数调用结束后作用域栈被清理，内存被回收
  - 闭包的上级函数执行完之后，闭包的上下文中关于上级函数的作用域不会被清理。因此闭包仍然能够访问上级作用域中的变量 

##### 应用
- Ajax请求的成功回调
- 事件绑定的回调方法
- setTimeout的延时回调
- 函数内部返回另一个匿名函数

#### interview questions
写一个mul函数，使用方法如下
```
console.log(mul(2)(3)(4)); // output : 24 
console.log(mul(4)(3)(4)); // output : 48
```
答案

```
function mul (x) {
    return function (y) { // anonymous function 
        return function (z) { // anonymous function 
            return x * y * z; 
        };
    };
}
```
```
function mul() {
    let args = [...arguments];
    function _mul() {
        args = args.concat([...arguments]);
        return mul.apply(null, args);
    }

    _mul.toString = function() {
        return args.reduce((a, b) => a * b);
    }

    return _mul;
}
```