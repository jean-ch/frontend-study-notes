#### 强缓存 [Cache-Control + Expires]
##### Expires (response header)  
  给浏览器设置一个绝对时间，超过这个绝对时间之后重新向服务器发送请求      
  存的是服务器的时间，判断的哦时候用的是客户端的时间，容易出错    
  因此引入cache-control: max-age    
##### Cache-Control (general header)     
  max-age设置的是相对缓存开始后多少秒   

优先级Cache-Control: max-age　> Expires   
过期时间内服务器上更新了客户端怎么获取最新的资源？协商缓存来处理  

#### 协商缓存
##### [Last-Modified (response header), If-Modified-Since (request header)]    
- 请求资源之后repsonse header加上Last-Modified字段
- 再次请求资源时request header加上If-Modified-Since字段
- 如果If-Modified-Since和服务器上的最后修改时间一致，返回304Not Modified，不一致则返回200和正常的资源内容 
- 收到304浏览器从缓存中加载资源，收到200把资源放入缓存并更新下次If-Modified-Since的值   

Last-Modified, If-Modified-Since是以秒为单位的。如果资源更新速度小于秒级怎么办呢？用[ETag, If-None-Match]  

##### [ETag, If-None-Match] 
- Etag是唯一标识符，和时间没有关系，只要资源变化这个标识符就不同，很好的补充了Last-Modifed的问题   
- If-None-Match后面跟上次接受到的Etag传过来的唯一标识符    

[ETag, If-None-Match]能够准确判断资源是否被更改，但需要对资源生成标识，牺牲了一部分性能   
优先级[ETag, If-None-Match] > [Last-Modified, If-Modified-Since]

#### 启发式缓存
如果没有以上确定缓存过期时间的字段，浏览器默认取10%(Date - Last-Modify)作为缓存的周期  

##### 优先级
强缓存 > 协商缓存 > 启发式缓存，因此Cache-Control > Expires > Etag > Last-Modified     
浏览器先检查Cache-Control, 如果Cache-Control是no-store，所有缓存都不会触发   
